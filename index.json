[
{
	"uri": "https://cgkiliu.github.io/leetcode%E9%A2%98%E8%A7%A3/",
	"title": "LeetCode题解",
	"tags": [],
	"description": "",
	"content": " Reveal Cards In Increasing Order In a deck of cards, every card has a unique integer. You can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck. Now, you do the following steps repeatedly, until all cards are revealed: Take the top card of the deck, reveal it, and take it out of the deck. If there are still cards in the deck, put the next top card of the deck at the bottom of the deck.\n  Reveal Cards In Increasing Order In a deck of cards, every card has a unique integer. You can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck. Now, you do the following steps repeatedly, until all cards are revealed: Take the top card of the deck, reveal it, and take it out of the deck. If there are still cards in the deck, put the next top card of the deck at the bottom of the deck.\n  "
},
{
	"uri": "https://cgkiliu.github.io/levedb%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/",
	"title": "LevelDB源码解析",
	"tags": [],
	"description": "数据库引擎LevelDB的源码解析",
	"content": " LevelDB数据类型 LevelDB数据类型\n  VarInt与编码 VarInt与编码\n  "
},
{
	"uri": "https://cgkiliu.github.io/levedb%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/leveldb%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/",
	"title": "LevelDB数据类型",
	"tags": [],
	"description": "LevelDB数据类型",
	"content": "  SequenceNumber  sequence ValueType  键\n user_key InternalKey ParsedInternalKey LookupKey memtable和跳跃表中存储的Key\nSequenceNumber SequenceNumber是一个无符号的64位整数类型，其高56位用来表示sequence，低8位用来表示ValueType\n  将sequence和ValueType封装在一起\n  static uint64_t PackSequenceAndType(uint64_t seq, ValueType t) { assert(seq \u0026lt;= kMaxSequenceNumber); assert(t \u0026lt;= kValueTypeForSeek); return (seq \u0026lt;\u0026lt; 8) | t; //seq左移8位，留下8位放type，总共64位 } // We leave eight bits empty at the bottom so a type and sequence# // can be packed together into 64-bits. // sequence最大值，前56位全是1 static const SequenceNumber kMaxSequenceNumber = ((0x1ull \u0026lt;\u0026lt; 56) - 1);  sequence sequence 为全局自增序列号，LevelDB 遇到一个修改操作，全局序列号自动加一。LevelDB 中的 Key 存储了多个版本的 Value。LevelDB 使用序列号来标记键值对的版本，序列号越大，对应的键值对越新。\nValueType ValueType用来表示该键的类型，是一个要被删除的键，还是一个插入或查询的键\nenum ValueType { kTypeDeletion = 0x0, kTypeValue = 0x1 }; static const ValueType kValueTypeForSeek = kTypeValue;  键 user_key user_key是levelDB用来表示用户插入或查询时使用的键值对中键的概念数据类型，对应于DB::Put(key, value)中的key,在levelDB中，用Slice数据类型来实际表示user_key\nInternalKey InternalKey是memtable内部使用的键，InternalKey由三部分组成： \u0026gt; InteralKey = User_key + Sequence+ ValueType\nParsedInternalKey 是InternalKey的辅助数据结构，用来帮助解析InternalKey，其声明如下：\nstruct ParsedInternalKey { Slice user_key; SequenceNumber sequence; ValueType type; ParsedInternalKey() { } // Intentionally left uninitialized (for speed)  ParsedInternalKey(const Slice\u0026amp; u, const SequenceNumber\u0026amp; seq, ValueType t) : user_key(u), sequence(seq), type(t) { } std::string DebugString() const; };  LookupKey 同样是一个辅助\nmemtable和跳跃表中存储的Key  leveldb中memtable实际上是对skipList的一个封装，也就是内存中，真正存储用户键值的数据结构是skipList。 skipList中Key是对用户键值的封装形成的:   [ Key = internal_key_size + internal_key + value_size + value ] 其中：internal_key_size和value_size的数据类型都是VarInt  "
},
{
	"uri": "https://cgkiliu.github.io/leetcode%E9%A2%98%E8%A7%A3/reveal_cards_in_increasing_order/",
	"title": "Reveal Cards In Increasing Order",
	"tags": [],
	"description": "",
	"content": " In a deck of cards, every card has a unique integer. You can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck. Now, you do the following steps repeatedly, until all cards are revealed: Take the top card of the deck, reveal it, and take it out of the deck. If there are still cards in the deck, put the next top card of the deck at the bottom of the deck. If there are still unrevealed cards, go back to step 1. Otherwise, stop. Return an ordering of the deck that would reveal the cards in increasing order. The first entry in the answer is considered to be the top of the deck.  题目大意  对于给定的一幅牌，每张牌上的数字都是不同的，我们可以对这副牌进行任意的排序，要求排完序后的这副牌满足以下操作： 1. 每次从牌堆顶部取走一张牌 2. 如果此时牌堆还有牌，将此时牌堆顶部的牌放置在牌堆底 3. 重复上述两步操作直到所有牌被取完 要求：按取走次序排列这副牌，上面的数字刚好是按序递增的 Example: Input: [17,13,11,2,3,5,7] Output: [2,13,3,11,5,17,7]\n 解题思路： 可以用一个队列来模拟取牌的过程，首先在队列中放入0~n-1的数字，数字i表示初始位置i，然后用队列模拟题目当中的操作， 第k次从队列中取出i表示，第k个取走的牌，它的初始位置是i。同时，题目要求取走的牌递增，那么首先对牌堆进行排序，每次从队列中取出一个位置i的时候，相应的从排好序的牌堆里取出牌k。\n复杂度：排序:O(nlogn) 取牌：O(n)\n代码 import( \u0026#34;sort\u0026#34; ) func deckRevealedIncreasing(deck []int) []int { sizeOfDeck := len(deck) queue := make(chan int, sizeOfDeck) for i:= 0; i \u0026lt; sizeOfDeck; i++{ queue \u0026lt;- i } sort.Ints(deck) ans := make([]int, sizeOfDeck) //从牌堆取牌的同时，取一个序号  for _, num := range deck{ idx := \u0026lt;-queue ans[idx] = num if len(queue) \u0026gt; 0{ fir := \u0026lt;-queue queue \u0026lt;- fir } } return ans }"
},
{
	"uri": "https://cgkiliu.github.io/leetcode%E9%A2%98%E8%A7%A3/test/",
	"title": "Reveal Cards In Increasing Order",
	"tags": [],
	"description": "",
	"content": "In a deck of cards, every card has a unique integer. You can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck. Now, you do the following steps repeatedly, until all cards are revealed: Take the top card of the deck, reveal it, and take it out of the deck. If there are still cards in the deck, put the next top card of the deck at the bottom of the deck. If there are still unrevealed cards, go back to step 1. Otherwise, stop. Return an ordering of the deck that would reveal the cards in increasing order. The first entry in the answer is considered to be the top of the deck.  "
},
{
	"uri": "https://cgkiliu.github.io/levedb%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/varint%E4%B8%8E%E7%BC%96%E7%A0%81/",
	"title": "VarInt与编码",
	"tags": [],
	"description": "VarInt与编码",
	"content": " VarInt LevelDB内部通过采用变长编码，对数据进行压缩来减少存储空间，采用CRC进行数据正确性校验。 传统的integer是以32位来表示的，存储需要4个字节，当如果整数大小在256以内，那么只需要用一个字节就可以存储这个整数，这样就可以节省3个字节的存储空间，Google varint就是根据这种思想来序列化整数的\n无符号 Varint 是一种紧凑的表示数字的方法。它用一个或多个字节来表示一个数字，值越小的数字使用越少的字节数。这能减少用来表示数字的字节数。\nVarint 中的每个 byte 的最高位 bit 有特殊的含义，如果该位为 1，表示后续的 byte 也是该数字的一部分，如果该位为 0，则结束。其他的 7 个 bit 都用来表示数字。因此小于 128 的数字都可以用一个 byte 表示。大于 128 的数字，会用两个字节。\n例如整数1的表示，仅需一个字节：\n0000 0001\n例如300的表示，需要两个字节：\n1010 1100 0000 0010\n采用 Varint，对于很小的 int32 类型的数字，则可以用 1 个 byte 来表示。当然凡事都有好的也有不好的一面，采用 Varint 表示法，大的数字则需要 5 个 byte 来表示。从统计的角度来说，一般不会所有的消息中的数字都是大数，因此大多数情况下，采用 Varint 后，可以用更少的字节数来表示数字信息。\n下图演示了 Google Protocol Buffer 如何解析两个 bytes。注意到最终计算前将两个 byte 的位置相互交换过一次，这是因为 Google Protocol Buffer 字节序采用 little-endian 的方式。\n"
},
{
	"uri": "https://cgkiliu.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://cgkiliu.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://cgkiliu.github.io/",
	"title": "Test slice",
	"tags": [],
	"description": "",
	"content": " time Getting up  Turn off alarm Get out of bed  "
}]